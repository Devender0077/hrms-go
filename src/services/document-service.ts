// Note: Toast notifications should be handled by the calling component using addToast from @heroui/react

export interface DocumentTemplate {
  id: string;
  type: 'offer_letter' | 'joining_letter' | 'experience_certificate' | 'noc_letter';
  name: string;
  content: string;
  variables: string[];
  letterhead?: {
    useCustom: boolean;
    customFile?: File;
    autoGenerated?: boolean;
  };
}

export interface DocumentData {
  candidateName?: string;
  employeeName?: string;
  position: string;
  department: string;
  salary?: string;
  startDate: string;
  endDate?: string;
  companyName: string;
  hrEmail: string;
  hrPhone: string;
  managerName?: string;
  benefits?: string;
  probationPeriod?: string;
  validityDays?: string;
  acceptanceDeadline?: string;
  hrManagerName?: string;
  [key: string]: any;
}

export interface CompanyBranding {
  logo?: string;
  companyName: string;
  address: string;
  phone: string;
  email: string;
  website?: string;
  primaryColor?: string;
  secondaryColor?: string;
}

class DocumentService {
  private baseUrl: string;

  constructor() {
    this.baseUrl = (import.meta as any).env?.VITE_API_BASE_URL || 'http://localhost:8000/api';
  }

  /**
   * Generate a professional letterhead using company branding
   */
  generateLetterhead(branding: CompanyBranding): string {
    const logoHtml = branding.logo 
      ? `<img src="${branding.logo}" alt="${branding.companyName}" style="max-height: 80px; margin-bottom: 20px;" />`
      : `<div style="height: 80px; background: linear-gradient(135deg, ${branding.primaryColor || '#3B82F6'}, ${branding.secondaryColor || '#8B5CF6'}); border-radius: 8px; display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
           <h1 style="color: white; margin: 0; font-size: 24px; font-weight: bold;">${branding.companyName}</h1>
         </div>`;

    return `
      <div style="max-width: 800px; margin: 0 auto; padding: 40px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: white;">
        <div style="text-align: center; margin-bottom: 40px; border-bottom: 2px solid #e5e7eb; padding-bottom: 20px;">
          ${logoHtml}
          <div style="color: #6b7280; font-size: 14px; line-height: 1.6;">
            <p style="margin: 5px 0;">${branding.address}</p>
            <p style="margin: 5px 0;">Phone: ${branding.phone} | Email: ${branding.email}</p>
            ${branding.website ? `<p style="margin: 5px 0;">Website: ${branding.website}</p>` : ''}
          </div>
        </div>
        <div style="content: ''; clear: both; display: table;">
    `;
  }

  /**
   * Replace template variables with actual data
   */
  replaceVariables(template: string, data: DocumentData): string {
    let processedTemplate = template;
    
    // Replace all variables in the format [VARIABLE_NAME]
    Object.keys(data).forEach(key => {
      const value = data[key] || '';
      const regex = new RegExp(`\\[${key.toUpperCase()}\\]`, 'g');
      processedTemplate = processedTemplate.replace(regex, value.toString());
    });

    return processedTemplate;
  }

  /**
   * Generate HTML content for the document
   */
  generateDocumentHTML(template: DocumentTemplate, data: DocumentData, branding: CompanyBranding): string {
    const letterhead = template.letterhead?.useCustom 
      ? this.generateLetterhead(branding)
      : this.generateLetterhead(branding);
    
    const processedContent = this.replaceVariables(template.content, data);
    
    const footer = `
        </div>
        <div style="margin-top: 60px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 12px;">
          <p>This document was generated on ${new Date().toLocaleDateString()}</p>
        </div>
      </div>
    `;

    return letterhead + processedContent + footer;
  }

  /**
   * Convert HTML to PDF using browser's print functionality
   */
  async generatePDF(htmlContent: string, filename: string): Promise<Blob> {
    return new Promise((resolve, reject) => {
      try {
        // Create a new window for printing
        const printWindow = window.open('', '_blank');
        if (!printWindow) {
          reject(new Error('Unable to open print window'));
          return;
        }

        printWindow.document.write(`
          <!DOCTYPE html>
          <html>
            <head>
              <title>${filename}</title>
              <style>
                @media print {
                  body { margin: 0; }
                  @page { margin: 0.5in; }
                }
                body {
                  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                  line-height: 1.6;
                  color: #333;
                }
                h1, h2, h3 { color: #1f2937; }
                .signature-section {
                  margin-top: 40px;
                  display: flex;
                  justify-content: space-between;
                }
                .signature-box {
                  width: 200px;
                  border-bottom: 1px solid #333;
                  padding-bottom: 5px;
                  text-align: center;
                }
              </style>
            </head>
            <body>
              ${htmlContent}
            </body>
          </html>
        `);

        printWindow.document.close();
        
        // Wait for content to load
        printWindow.onload = () => {
          setTimeout(() => {
            printWindow.print();
            printWindow.close();
            resolve(new Blob([htmlContent], { type: 'text/html' }));
          }, 500);
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Send document via email
   */
  async sendDocument(
    documentType: string,
    recipientEmail: string,
    documentBlob: Blob,
    subject: string,
    message: string
  ): Promise<boolean> {
    try {
      const formData = new FormData();
      formData.append('document_type', documentType);
      formData.append('recipient_email', recipientEmail);
      formData.append('document', documentBlob, `${documentType}.pdf`);
      formData.append('subject', subject);
      formData.append('message', message);

      const response = await fetch(`${this.baseUrl}/documents/send`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        throw new Error('Failed to send document');
      }

      return true;
    } catch (error) {
      console.error('Error sending document:', error);
      // Toast notification should be handled by the calling component
      return false;
    }
  }

  /**
   * Generate and send offer letter
   */
  async generateAndSendOfferLetter(
    candidateEmail: string,
    candidateName: string,
    position: string,
    department: string,
    salary: string,
    startDate: string,
    template: DocumentTemplate,
    branding: CompanyBranding
  ): Promise<boolean> {
    try {
      const data: DocumentData = {
        candidateName,
        position,
        department,
        salary,
        startDate,
        companyName: branding.companyName,
        hrEmail: branding.email,
        hrPhone: branding.phone,
        validityDays: '30',
        acceptanceDeadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString(),
        hrManagerName: 'HR Manager'
      };

      const htmlContent = this.generateDocumentHTML(template, data, branding);
      const documentBlob = await this.generatePDF(htmlContent, `offer-letter-${candidateName.replace(/\s+/g, '-')}.pdf`);
      
      const subject = `Job Offer - ${position} at ${branding.companyName}`;
      const message = `Dear ${candidateName},\n\nPlease find attached your job offer letter for the position of ${position}.\n\nBest regards,\n${branding.companyName} HR Team`;

      return await this.sendDocument('offer_letter', candidateEmail, documentBlob, subject, message);
    } catch (error) {
      console.error('Error generating offer letter:', error);
      // Toast notification should be handled by the calling component
      return false;
    }
  }

  /**
   * Generate and send joining letter
   */
  async generateAndSendJoiningLetter(
    employeeEmail: string,
    employeeName: string,
    position: string,
    department: string,
    startDate: string,
    template: DocumentTemplate,
    branding: CompanyBranding
  ): Promise<boolean> {
    try {
      const data: DocumentData = {
        employeeName,
        position,
        department,
        startDate,
        companyName: branding.companyName,
        hrEmail: branding.email,
        hrPhone: branding.phone,
        hrManagerName: 'HR Manager'
      };

      const htmlContent = this.generateDocumentHTML(template, data, branding);
      const documentBlob = await this.generatePDF(htmlContent, `joining-letter-${employeeName.replace(/\s+/g, '-')}.pdf`);
      
      const subject = `Joining Letter - Welcome to ${branding.companyName}`;
      const message = `Dear ${employeeName},\n\nWelcome to ${branding.companyName}! Please find attached your joining letter.\n\nBest regards,\n${branding.companyName} HR Team`;

      return await this.sendDocument('joining_letter', employeeEmail, documentBlob, subject, message);
    } catch (error) {
      console.error('Error generating joining letter:', error);
      // Toast notification should be handled by the calling component
      return false;
    }
  }

  /**
   * Generate and send experience certificate
   */
  async generateAndSendExperienceCertificate(
    employeeEmail: string,
    employeeName: string,
    position: string,
    department: string,
    startDate: string,
    endDate: string,
    template: DocumentTemplate,
    branding: CompanyBranding
  ): Promise<boolean> {
    try {
      const data: DocumentData = {
        employeeName,
        position,
        department,
        startDate,
        endDate,
        companyName: branding.companyName,
        hrEmail: branding.email,
        hrPhone: branding.phone,
        hrManagerName: 'HR Manager'
      };

      const htmlContent = this.generateDocumentHTML(template, data, branding);
      const documentBlob = await this.generatePDF(htmlContent, `experience-certificate-${employeeName.replace(/\s+/g, '-')}.pdf`);
      
      const subject = `Experience Certificate - ${branding.companyName}`;
      const message = `Dear ${employeeName},\n\nPlease find attached your experience certificate.\n\nBest regards,\n${branding.companyName} HR Team`;

      return await this.sendDocument('experience_certificate', employeeEmail, documentBlob, subject, message);
    } catch (error) {
      console.error('Error generating experience certificate:', error);
      // Toast notification should be handled by the calling component
      return false;
    }
  }

  /**
   * Generate and send NOC letter
   */
  async generateAndSendNOCLetter(
    employeeEmail: string,
    employeeName: string,
    position: string,
    department: string,
    template: DocumentTemplate,
    branding: CompanyBranding
  ): Promise<boolean> {
    try {
      const data: DocumentData = {
        employeeName,
        position,
        department,
        startDate: new Date().toISOString().split('T')[0],
        companyName: branding.companyName,
        hrEmail: branding.email,
        hrPhone: branding.phone,
        hrManagerName: 'HR Manager'
      };

      const htmlContent = this.generateDocumentHTML(template, data, branding);
      const documentBlob = await this.generatePDF(htmlContent, `noc-letter-${employeeName.replace(/\s+/g, '-')}.pdf`);
      
      const subject = `No Objection Certificate - ${branding.companyName}`;
      const message = `Dear ${employeeName},\n\nPlease find attached your No Objection Certificate.\n\nBest regards,\n${branding.companyName} HR Team`;

      return await this.sendDocument('noc_letter', employeeEmail, documentBlob, subject, message);
    } catch (error) {
      console.error('Error generating NOC letter:', error);
      // Toast notification should be handled by the calling component
      return false;
    }
  }
}

export const documentService = new DocumentService();
